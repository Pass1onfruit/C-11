自动推导类型

为什么需要？
在定义变量时，必须先给出变量的实际类型，编译器才允许定义，但有些情况下可能不知道需要实际类型怎么给，或者类型写起来特别复杂

//typeid 能查看类型不能用其结果类定义类型
typeid(v). name () 查看v对象的类型

//dynamic_cast只能应用于含有虚函数的继承体系中
//用decltype推演a+b的实际类型，作为定义c的类型
dec1type (a + b) c;

使用auto修饰的变量，是具有自动存储器的局部变量，C++11中，auto不再是一个存储类型指示符，而是作为一个新的类型指 示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。

使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型
auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变 量实际的类型。

使用auto定义变量时必须对其进行初始化
用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&

当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个 类型进行推导，然后用推导出来的类型定义其他变量。
void TestAuto()
 {
    auto a = 1, b = 2;  
  //auto c = 3, d = 4.0;  // 该行代码会编译失败，因为c和d的初始化表达式类型不同
 }

auto不能作为函数的参数
//void TestAuto(auto a) {} //error

范围for：
底层是由迭代器支持的
for循环迭代的范围必须是确定的
对于数组而言，就是数组中第一个元素和最后一个元素的范围
对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围

for (auto e: v)
cout << e << " ";

//这里是取v容器中的值依次赋值给e,也就是说对e的改变不会影响v
for (auto& e: v) e *= 2;

//当e拷贝大家大的对象时,注意用&
vector<string> vs("sort", "string"};
for (const auto& e: vs)
//......
