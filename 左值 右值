C++98
左值引用
int a = 0;
int& b = a;

C++11
右值引用

都是引用，都是给对象取别名

左值，右值：
int main()
{
	// a是左值, 10是一个右值
	int a = 10;
	//在左边的一定左值吗？是的
	//普通类型的变量，可以取地址，都认为是左值

	//在右边的一定是右值吗？不一定，比如下面表达式的a
	int b = a;
	//左值通常是：可以被修改的对象
	//太值通常是：表达式的返回值（临时对象）
	int c = a + b;
}

const修饰的常量，不可修改，只读类型的,理论应该按照右值对待，但因为其可以取地址（如果只是
const类型常量的定义，编译器不给其开辟空间,如果对该常量取地址时，编译器才为其开辟空间）C++11认为其是左值

int main()
{
	//左值引用可以引用E值
	int a = 10; int& b = a;
	//左值引用能否引用右值?不行,但是const左值引用可以
	const int& c = 10;
	const int& d = a + b;
	return 0;
}

C++11对右值进行了严格的区分：
1  C语言中的纯右值,比如：atb, 100
2  将亡值（移动构造，移动赋值）：
比如表达式的中间结果、函数按照值的方式进行返回

右值引用：
int main()
{
	//右引用引用右值
	//右值引用能否引用左值?
	//不能，但是可以使用move将左值转换成右值，进行右值引用
	int a = 10;
	//int&& b =a: //编译报错
	int&& c = 10;
	int&& b = move(a);
	int& d = a + 10
}


左值引用应用：
1、做参数：
swap (T& a, T& b)->输出型参数 + func (const vector<int)& v)->提高传递效率
2、做返回值如:：
T& operator[] (sizet index)->改变返回对象+ vector<T& operator=(const vector<T& v)->提高效率

右值引用应用：
1、移动构造和移动赋值
2、容器的插入

一般需要深拷贝的类才使用移动构造
